# Single-Use Keys

As you've seen, encryption requires keys. Keys are just strings of data that are used to secure a message. Similar to how a password protects access to an online account, cryptographic keys protect a cryptographic message. A key can be a password, but typically when we talk about keys we're talking about longer, more secure strings of data.

For example, a randomly generated, 256-bit key, represented in hex, would look like this:

```
ddda0e759e1c1c8861f350752ce66eb972207570e0b0f9db1a405707f90b4e67
```

## Avoid Key Reuse

Keys can be used many times, but the less often a key is used, the less likely it is to become compromised. For this reason, single-use keys are often the most secure.

The biggest problem with single-use keys is that it's hard to remember a new key for each message. As a result, single-use keys can be inconvenient.

Single-use keys are best used in systems where a human doesn't need to remember what the key is. For example, maybe a new key can be generated by code for each message.

## Assignment

At Passly, each user's password vault has its own encryption key, and each time a user decrypts their vault, we generate a new key. Because the user doesn't need to remember the key, we can make it long and random, and we can frequently generate new keys.

Complete the generateRandomKey function. It accepts a length in bytes, and returns a random key of that length, formatted in a hex string.

- Use the rand.Read function.
- Format the key as a hex string using fmt.Sprintf function and the %x formatting verb.

`rand.Read` accepts a `[]byte` slice, and fills it with random bytes: just make sure that the slice is the right length. It returns the number of bytes written, and an error. You don't need to worry about the number of bytes written, but you should check for an error.

## Note

We use `rand.Read` and `rand.Seed` from the `math/rand` package in this assignment, even though they are deprecated, to ensure predictable results for learning purposes. In real-world applications, you should use `crypto/rand.Read` for secure randomness and `rand.New(rand.NewSource(seed))` for a local random generator, as these offer better security and reliability.

### Code

```go
package main

import (
	"fmt"
	"math/rand"
)

func generateRandomKey(length int) (string, error) {
	key := make([]byte, length) // key == []byte{0, 0, 0, 0, 0, ....}
	_, err := rand.Read(key) // will fill the slice with random bits
	if  err != nil {
		return "", err
	}
	return fmt.Sprintf("%x", key), nil // %x will format the key as a hex string
}
```

### Q & A

`Q:` Why is this not working: `var randomBytes [length]byte`

`A:`

Ah, I see you've declared an array of bytes using `[length]byte`. The problem lies in how Go handles arrays versus slices.

The rand.Read function requires a slice `([]byte)`, not a fixed-size array `([length]byte)`. In Go, these two types are not interchangeable, so you get a mismatch when trying to use your array with rand.Read.

For example:

- `[length]byte` is an array of a fixed size, which means the size must be known at compile-time.
- `[]byte` is a slice, which is more flexible and dynamic, allowing rand.Read to write data into it.

To fix this, how could you create a flexible `[]byte` slice with the desired length? How might you use the `make` function for this purpose?

-> The make function is perfect here. Using `key := make([]byte, length)` creates a slice of length bytes, which is exactly what you need for rand.Read.

This will provide a key slice that can be filled with random bytes. Once you've made that adjustment, can you use rand.Read(key) to populate it? Remember to handle any potential errors from `rand.Read`.

## Single-Use Keys Review

Avoid key reuse if at all possible.

### Key Takeaways

- Using a key more than once adds security risks. That doesn't mean you should never reuse a key, but you should be aware of the risks.
- We can't always use single-use keys, sometimes we need to reuse a key. For example, if two parties need to share a key, they probably can't generate a new key every time they need to use it.
- If a key doesn't need to be remembered by a human, you can make it long and random. We only use short, less secure passwords when humans need to remember them.
- Humans kind of suck. They make security hard.
