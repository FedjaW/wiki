# RSA Key Generation

Something you never want to do in the real world is to write your own cryptography code from scratch. Always use well-tested crypto libraries in production.

That said, we've been asked at Passly to write our own RSA from scratch to compare against the Go standard library's implementation. Don't worry, it's just for benchmarking purposes.

## Generating Big Numbers

First of all, we need to generate some really big numbers. Go has a library for that: math/big. It's a bit tricky to use, but we'll figure it out together.

1. 2 very large prime numbers are generated, we'll call them `p` and `q`
2. The first part of the public key is generated by multiplying `p` and `q` together, we'll call this `n`

## Assignment

Complete the generatePrivateNums and getN functions.

### generatePrivateNums(keysize int) (*big.Int, *big.Int)

Use the provided `getBigPrime function` to generate two prime numbers of the given keysize in bits. Be sure to generate `p` first, as we're relying on the determinism of the random number generator. (Normally we would use the `crypto/rand` package's rand.Prime if we wanted true randomness).

### getN(p, q *big.Int) *big.Int

Use the `math/big` package's .Mul method to multiply `p` and `q` together to get `n`.

### Notes

#### Big Integers

Notice that we're using *big.Int instead of `int` or `int64`. That's because we need to be able to handle numbers that are too big to fit in a regular integer. Most of the arithmetic with big integers is done through methods on the `*big.Int` type, and they mutate the pointer receiver.

#### Those Numbers Are Huge

You might notice that it takes a minute or so to generate those numbers, and that's because they're really big. Think about a   600-digit number! That's a `1` with `600` `0`s after it.

### Solution

```go
package main

import (
	"math/big"
)

func generatePrivateNums(keysize int) (*big.Int, *big.Int) {
	p, _ := getBigPrime(keysize)
	q, _ := getBigPrime(keysize)
	return p, q
}

func getN(p, q *big.Int) *big.Int {
	n := new(big.Int)
	n.Mul(p, q)
	return n
}
```

// helpers.go

```go
package main

import (
	"errors"
	"fmt"
	"io"
	"math/big"
	mrand "math/rand"
)

// firstNDigits returns the first 'numDigits' digits of the big integer n.
func firstNDigits(n big.Int, numDigits int) string {
	if len(n.String()) < numDigits {
		return fmt.Sprintf("%v", n.String())
	}
	return fmt.Sprintf("%v...", n.String()[:numDigits])
}

var randReader = mrand.New(mrand.NewSource(0))

// getBigPrime generates a random prime number of the given size.
func getBigPrime(bits int) (*big.Int, error) {
	if bits < 2 {
		return nil, errors.New("prime size must be at least 2-bit")
	}
	b := uint(bits % 8)
	if b == 0 {
		b = 8
	}
	bytes := make([]byte, (bits+7)/8)
	p := new(big.Int)
	for {
		if _, err := io.ReadFull(randReader, bytes); err != nil {
			return nil, err
		}
		bytes[0] &= uint8(int(1<<b) - 1)
		if b >= 2 {
			bytes[0] |= 3 << (b - 2)
		} else {
			bytes[0] |= 1
			if len(bytes) > 1 {
				bytes[1] |= 0x80
			}
		}
		bytes[len(bytes)-1] |= 1
		p.SetBytes(bytes)
		if p.ProbablyPrime(20) {
			return p, nil
		}
	}
}
```